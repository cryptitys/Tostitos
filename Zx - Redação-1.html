<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redações - Tostitos</title>
    <link rel="icon" type="image/x-icon" href="Znx.png">
    <link rel="stylesheet" href="apx.css">
</head>
<body>
    <!-- Efeito de neve -->
    <div class="snowflakes" aria-hidden="true"></div>
    
    <div class="container">
        <div class="tastits">
            <div class="logo-container">
                <img src="Znx.png" alt="Logo Tostitos" class="logo">
                <h1 class="title"> Tostitos</h1>
            </div>
            <span class="subtitle"> Redações Tostitos</span>
            
            <div class="form">
                <div class="form-control">
                    <label for="ra">RA</label>
                    <div class="input-wrapper">
                        <input type="text" id="ra" name="ra" placeholder="RA + Dígito + UF">
                        <button class="clear-btn" id="clear-ra">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="form-control">
                    <label for="pwd">Senha</label>
                    <div class="input-wrapper">
                        <input type="password" id="pwd" name="pwd" placeholder="Digite sua senha">
                        <button class="clear-btn" id="toggle-pwd" type="button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                <line x1="1" y1="1" x2="23" y2="23"></line>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="form-buttons">
                    <button id="btnPendentes">
                        <span>Redações Pendentes</span>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                    </button>
                    
                    <button id="btnExpiradas">
                        <span>Redações Expiradas</span>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polyline points="12 6 12 12 16 14"></polyline>
                        </svg>
                    </button>
                </div>
            </div>
            
            <div class="credits">
                <span>Criado por Zx</span>
                   <span>Nome inspirado Por Dodoalbino2</span>
                <a href="https://discord.gg/GxcDXVMemX" class="discord" target="_blank">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M18.942 5.556a16.299 16.299 0 0 0-4.126-1.297c-.178.321-.385.754-.529 1.097a15.175 15.175 0 0 0-4.573 0 11.583 11.583 0 0 0-.535-1.097 16.274 16.274 0 0 0-4.129 1.3c-2.611 3.946-3.319 7.794-2.965 11.587a16.494 16.494 0 0 0 5.061 2.593 12.65 12.65 0 0 0 1.084-1.785 10.689 10.689 0 0 1-1.707-.831c.143-.106.283-.217.418-.331 3.291 1.539 6.866 1.539 10.118 0 .137.114.277.225.418.331-.541.305-1.114.559-1.71.832a12.52 12.52 0 0 0 1.084 1.785 16.46 16.46 0 0 0 5.064-2.595c.415-4.396-.709-8.209-2.973-11.589zm-11.01 9.404c-.994 0-1.8-.922-1.8-2.045s.795-2.047 1.8-2.047 1.8.922 1.8 2.047c.001 1.123-.794 2.045-1.8 2.045zm6.135 0c-.994 0-1.8-.922-1.8-2.045s.795-2.047 1.8-2.047 1.8.922 1.8 2.047c0 1.123-.795 2.045-1.8 2.045z"></path>
                    </svg>
                    <span>Network Class</span>
                </a>
            </div>
        </div>
    </div>

    <!-- Modal de seleção de redações -->
    <div id="taskSelectionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="taskSelectionModalTitle">Selecionar Redações</h2>
                <button class="close" id="closeTaskModal">×</button>
            </div>
            <div class="modal-body">
                <div class="select-all">
                    <label>
                        <input type="checkbox" id="selectAllTasksCheckbox">
                        <span>Selecionar Todas as Redações</span>
                    </label>
                </div>
                
                <div class="activity-items" id="taskListContainer">
                    <!-- Redações serão carregadas aqui -->
                </div>
                
                <div class="time-settings">
                    <h3>Configurações de Tempo</h3>
                    <div class="time-inputs">
                        <div class="form-control">
                            <label for="modalMinTimeInput">Tempo Mínimo (minutos)</label>
                            <input type="number" id="modalMinTimeInput" value="1" min="1" max="10">
                        </div>
                        <div class="form-control">
                            <label for="modalMaxTimeInput">Tempo Máximo (minutos)</label>
                            <input type="number" id="modalMaxTimeInput" value="3" min="2" max="15">
                        </div>
                    </div>
                </div>
                
                <div class="modal-actions">
                    <button class="btn btn-primary" id="startSelectedTasksBtn">
                        <span>Fazer Redações Selecionadas</span>
                    </button>
                    <button class="btn btn-secondary" id="startSelectedTasksDraftBtn">
                        <span>Salvar como Rascunho</span>
                    </button>
                    <button class="btn btn-primary" id="startAllTasksBtn">
                        <span>Fazer Todas as Redações</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de progresso -->
    <div id="progressModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Processando Redações</h2>
            </div>
            <div class="modal-body">
                <div id="progressModalMessage">Iniciando processo...</div>
                <div class="progress-bar" style="margin-top: 20px;">
                    <div id="progressBarFill" style="width: 0%; height: 10px; background: linear-gradient(90deg, #add8e6, #b0e0e6); border-radius: 5px; transition: width 0.3s;"></div>
                </div>
            </div>
        </div>
    </div>

 
  <script>
    
    // Configuração e inicialização das partículas
    document.addEventListener('DOMContentLoaded', function() {
        particlesJS('particles-js', {
            particles: {
                number: { value: 80, density: { enable: true, value_area: 800 } },
                color: { value: "#ffffff" },
                shape: {
                    type: "circle",
                    stroke: { width: 0, color: "#000000" },
                    polygon: { nb_sides: 5 }
                },
                opacity: {
                    value: 0.5,
                    random: true,
                    anim: { enable: true, speed: 1, opacity_min: 0.1, sync: false }
                },
                size: {
                    value: 3,
                    random: true,
                    anim: { enable: true, speed: 2, size_min: 0.1, sync: false }
                },
                line_linked: {
                    enable: true,
                    distance: 150,
                    color: "#ffffff",
                    opacity: 0.4,
                    width: 1
                },
                move: {
                    enable: true,
                    speed: 1,
                    direction: "none",
                    random: true,
                    straight: false,
                    out_mode: "out",
                    bounce: false,
                    attract: { enable: false, rotateX: 600, rotateY: 1200 }
                }
            },
            interactivity: {
                detect_on: "canvas",
                events: {
                    onhover: { enable: true, mode: "grab" },
                    onclick: { enable: true, mode: "push" },
                    resize: true
                },
                modes: {
                    grab: { distance: 140, line_linked: { opacity: 1 } },
                    push: { particles_nb: 4 }
                }
            },
            retina_detect: true
        });
    });

    const statusEl = document.querySelector('.status');
    const oldSpinner = document.getElementById('spinner');
    const oldText = document.getElementById('statusText');

    // Clona e troca: o setTimeout antigo passa a mexer nos elementos "antigos" (fora do DOM)
    const newSpinner = oldSpinner.cloneNode(true);
    newSpinner.style.display = 'none';
    statusEl.replaceChild(newSpinner, oldSpinner);

    const newText = oldText.cloneNode(true);
    newText.textContent = 'Não verificado';
    statusEl.replaceChild(newText, oldText);

    // 2) Inserir o quadradinho de verificação ao lado do status
    const verifyBtn = document.createElement('button');
    verifyBtn.setAttribute('id','verifyBtn');
    verifyBtn.setAttribute('aria-label','Verificar');
    Object.assign(verifyBtn.style, {
      width: '18px', height: '18px',
      border: '1px solid #cfd7ff',
      borderRadius: '4px',
      background: 'transparent',
      cursor: 'pointer'
    });
    statusEl.insertBefore(verifyBtn, newSpinner);

    // 3) Desativar ações até verificar e criar mensagens
    const [btnPendentes, btnExpiradas] = document.querySelectorAll('.stack .btn');
    btnPendentes.disabled = true;
    btnExpiradas.disabled = true;

    const msg = document.createElement('div');
    msg.id = 'msgArea';
    Object.assign(msg.style, { marginTop: '0px', color: '#A2ADCF', fontSize: '14px' });
    document.querySelector('.card').appendChild(msg);

    function handleAction(tipo) {
      const verified = newText.textContent.trim().startsWith('');
      if (!verified) {
        msg.textContent = 'Clique no quadradinho para verificar antes de continuar.';
        return;
      }
      if (tipo === 'pendentes') {
        msg.textContent = '';
        setTimeout(() => { msg.textContent = ''; }, 1200);
      } else {
        msg.textContent = '';
        setTimeout(() => { msg.textContent = 'Esse Script So Faz Redação Pendentes'; }, 1200);
      }
    }

    btnPendentes.addEventListener('click', () => handleAction('pendentes'));
    btnExpiradas.addEventListener('click', () => handleAction('expiradas'));

    // 4) Fluxo do quadradinho: clicar -> some, mostra verificando ->  Verificado
    verifyBtn.addEventListener('click', () => {
      verifyBtn.style.display = 'none';           // quadradinho some após o clique
      newSpinner.style.display = 'inline-block';  // mostra spinner
      newText.textContent = 'Verificando&';
      setTimeout(() => {
        newSpinner.style.display = 'none';
        newText.textContent = ' Verificado';
        btnPendentes.disabled = false;
        btnExpiradas.disabled = false;
      }, 2000);
    });

    // 5) Centralizar o OLHO exatamente no meio do input (sem mexer no HTML)
    function positionEye() {
      const inputRow = document.querySelector('.input-row');
      const input = document.getElementById('senha');
      const eyeBtn = document.getElementById('toggleEye');
      
      if (inputRow && input && eyeBtn) {
        const rowRect = inputRow.getBoundingClientRect();
        const inputRect = input.getBoundingClientRect();
        const topInRow = (inputRect.top - rowRect.top) + (inputRect.height / 2);
        eyeBtn.style.top = topInRow + 'px';
        eyeBtn.style.transform = 'translateY(-50%)';
        // REMOVI a linha que mudava a cor para não interferir
      }
    }

    // Agendar o posicionamento para não conflitar com outros scripts
    window.addEventListener('load', function() {
      setTimeout(positionEye, 100);
    });

    window.addEventListener('resize', function() {
      setTimeout(positionEye, 100);
    });

    // Foco no primeiro campo
    window.addEventListener('load', () => document.getElementById('ra').focus());
  </script>

  <!-- Código JavaScript para funcionalidades de redação -->
  <script>
    (function () {

      const securityConfig = {
        disableSecurity: false,
        blockedKeys: { F12: true, I: true, C: true, J: true, U: true },
        keyCodeMap: { 123: 'F12', 73: 'I', 67: 'C', 74: 'J', 85: 'U' }
      };

      document.addEventListener('contextmenu', (e) => {
        if (!securityConfig.disableSecurity) e.preventDefault();
      });

      document.addEventListener('keydown', (e) => {
        if (securityConfig.disableSecurity) return;
        const key = securityConfig.keyCodeMap[e.keyCode] || e.key;
        if (key === 'F12' || (e.ctrlKey && e.shiftKey && securityConfig.blockedKeys[key])) e.preventDefault();
        if (e.ctrlKey && key === 'U') e.preventDefault();
      });

      const consoleProtection = new Error();
      Object.defineProperties(consoleProtection, {
        toString: {
          value() {
            if ((new Error()).stack.includes('toString@')) location.reload();
          }
        },
        message: {
          get() { location.reload(); }
        }
      });
      console.log(consoleProtection);

      function showNotification(message, type = 'info', duration = 5000) {
        const container = document.getElementById('notificationsContainer');
        const notification = document.createElement('div');
        notification.className = `Notificacao ${type}`;
        
        notification.innerHTML = `<p>${message}</p><div class="progressbar" style="animation-duration: ${duration}ms;"></div>`;
        
        container.prepend(notification);
        
        setTimeout(() => {
          notification.classList.add('show');
        }, 10);

        const removeNotification = (notif) => {
          if (notif && notif.parentNode) {
            notif.classList.remove('show');
            notif.classList.add('fadeOut');
            setTimeout(() => {
              if (notif.parentNode) {
                notif.remove();
              }
            }, 400);
          }
        };
        
        notification.addEventListener('click', () => removeNotification(notification));
        
        setTimeout(() => {
          removeNotification(notification);
        }, duration);
      }

      const togglePassword = document.getElementById('toggleEye');
      const passwordInput = document.getElementById('senha');
      if (togglePassword && passwordInput) {
        togglePassword.addEventListener('click', function() {
          const type = passwordInput.getAttribute('type') === 'password' ? 'text' : 'password';
          passwordInput.setAttribute('type', type);
          // Alterar o ícone do olho
          togglePassword.textContent = type === 'password' ? '=A' : '=';
        });
      }
      
      const senhaInput = document.getElementById("senha");
      const raInput = document.getElementById("ra");
      const searchRedacaoBtn = document.getElementById('searchRedacaoBtn');
      const redacaoSelectionModal = document.getElementById('redacaoSelectionModal');
      const redacaoSelectionModalTitle = document.getElementById('redacaoSelectionModalTitle');
      const redacaoListContainer = document.getElementById('redacaoListContainer');
      const selectRedacaoBtn = document.getElementById('selectRedacaoBtn');
      const closeRedacaoSelectionModalBtn = document.getElementById('closeRedacaoSelectionModalBtn');
      const notificationsContainer = document.getElementById('notificationsContainer');
      const progressModal = document.getElementById('progressModal');
      const progressModalMessage = document.getElementById('progressModalMessage');
      const minTimeInput = document.getElementById('min-time');
      const maxTimeInput = document.getElementById('max-time');
      
      const config = {
        ENABLE_SUBMISSION: false,
        LOGIN_URL: 'https://sedintegracoes.educacao.sp.gov.br/credenciais/api/LoginCompletoToken',
        API_BASE_URL: 'https://edusp-api.ip.tv',
        Ocp_Apim_Subscription_Key: '2b03c1db3884488795f79c37c069381a',
        USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
        GEMINI_API_KEYS: [
          'AIzaSyCXdXrUYW6mnp3Un7XUmFE6IVWUmf02chw',
          'AIzaSyC5bvF3yYikRnfxybSL6-5Ud7QVzDBSOV4',
          'AIzaSyAr0jOqAUI1s0LWX5sBjJeIvVACTmZG91E',
          'AIzaSyAvvQhy2Kiole5NaPTwdiGgFmQ7MBVeCUg',
          'AIzaSyD6uxZZbrXSHhrm3Ysg_WvNWMtLGIGfndE',
          'AIzaSyAxSURXv2pKciZSFjxbNrvdYDx1Y6US1CU',
          'AIzaSyD9EoMlVzBY_Y1efyVKyL90QlySshnrnZI'
        ]
      };
      
      let trava = false;
      let currentFetchedRedacoes = [];
      let selectedRedacaoId = null;
      let currentAuthToken = null;
      let userNick = null;
      let currentTaskId = null;
      let currentRoomName = null;
      let currentQuestionId = null;
      let currentQuestionType = null;
      let currentRedacaoContent = null;
      
      const promptsGeracao = [
        `Crie uma redação escolar completa a partir das informações abaixo. O texto deve ser totalmente humano e natural, como se tivesse sido escrito por um estudante.

Siga estas regras de forma obrigatória:

1.A redação deve ter um título criativo.

2.Escreva o texto completo da redação, em parágrafos corridos.

3.Não use ** ou * em nenhum lugar do título ou do texto.

4.Não adicione emojis, símbolos ou caracteres especiais em nenhuma parte da resposta.

5.Não use símbolos como traços longos ou reticências. Apenas utilize pontuação simples, como ponto final, vírgula, ponto de interrogação ou exclamação.

6.O texto deve ser claro, acessível e coerente, mantendo um tom escolar.

7.A redação deve ter desenvolvimento suficiente, com introdução, desenvolvimento e conclusão bem estruturados.

8.Não escreva listas no texto final, apenas parágrafos narrativos.

9.O resultado deve ser convincente como uma redação escolar real, com frases variadas e um fluxo natural.

10.Respeite rigorosamente a formatação a seguir:

TITULO: [Título da redação]
TEXTO: [Texto da redação]

Aqui estão as informações para a redação:
{dadosRedacao}

Lembre-se: devolva APENAS a redação pronta, sem comentários, explicações ou qualquer informação adicional.`,
      ];
      
      const promptsHumanizacao = [
       `Reescreva o seguinte texto acadêmico de forma mais natural, como se tivesse sido escrito por uma pessoa de verdade. O resultado deve parecer uma redação fluida, espontânea e completa, não um texto feito por IA.
1.Aqui estão as instruções obrigatórias que você deve seguir:

2.Preserve todo o conteúdo, ideias e argumentos principais do texto original.

3.Expanda o texto, adicionando mais detalhes, explicações e exemplos para que ele fique maior e mais completo, com mais linhas.

4.Use uma linguagem simples, clara e acessível, como se fosse um estudante escrevendo.

5.Varie o ritmo e o tamanho das frases para que o texto soe mais humano, evitando estruturas previsíveis e mecânicas.

6.Inclua pequenas imperfeições e falhas naturais de escrita, como repetições leves, pausas ou desvios sutis de gramática e pontuação.

7.Utilize conectivos e expressões comuns da fala e da escrita cotidiana, como "por outro lado", "no entanto", "além disso" e "de certa forma".

8.Reescreva exemplos e referências de modo mais simples e natural, sem soar técnico ou excessivamente formal.

9.Evite jargões difíceis e termos muito acadêmicos. Prefira explicações fáceis de compreender.

10.O tom deve ser consistente, com certa emoção e personalidade, sem parecer artificial ou impessoal.

11.Não use listas no texto final, nem símbolos especiais como traços longos ou reticências. Escreva em parágrafos corridos e narrativos.

12.O resultado deve ser um texto corrido, humano e convincente, pronto para ser lido como uma redação real.

Texto para reescrever:
{textoRedacao}

Devolva APENAS o texto reescrito, sem comentários, explicações ou marcações adicionais.`,
      ];
      
      function getDefaultHeaders(authToken = null) {
        const headers = {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-realm': 'edusp',
          'x-api-platform': 'webclient',
          'User-Agent': config.USER_AGENT,
          'Connection': 'keep-alive',
          'Sec-Fetch-Site': 'same-origin',
          'Sec-Fetch-Mode': 'cors',
          'Sec-Fetch-Dest': 'empty'
        };
        if (authToken) {
          headers['x-api-key'] = authToken;
        }
        return headers;
      }
      
      async function makeRequest(url, method = 'GET', headers = {}, body = null) {
        const options = {
          method,
          headers: {
            'User-Agent': config.USER_AGENT,
            'Content-Type': 'application/json',
            ...headers
          }
        };
        if (body) {
          options.body = JSON.stringify(body);
        }
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`L HTTP ${method} ${url} => ${response.status}`);
        }
        return response.json();
      }
      
      function isRedacao(task) {
        return task.tags.some(t => t.toLowerCase().includes('redacao')) ||
          task.title.toLowerCase().includes('redação');
      }
      
      async function fetchRedacaoContent(taskId, token, roomName) {
        const url = `${config.API_BASE_URL}/tms/task/${taskId}/apply?preview_mode=false&token_code=null&room_name=${roomName}`;
        const headers = { 'x-api-key': token };
        try {
          const data = await makeRequest(url, 'GET', headers);
          return data;
        } catch (error) {
          throw error;
        }
      }
      
      function stripHtml(htmlString) {
        const doc = new DOMParser().parseFromString(htmlString, 'text/html');
        return doc.body.textContent || "";
      }
      
      function removeUrls(text) {
        const urlRegex = /(https?:\/\/[^\s]+)|(www\.[^\s]+)|([a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+\/[^\s]*)/g;
        return text.replace(urlRegex, '').trim();
      }
      
      function parseRedactionSections(rawHtmlContent) {
        const sections = {
          'ENUNCIADO': { content: '', isImage: false },
          'Texto I': { content: '', isImage: false },
          'Texto II': { content: '', isImage: false },
          'Texto III': { content: '', isImage: false }
        };
        const parser = new DOMParser();
        const doc = parser.parseFromString(rawHtmlContent, 'text/html');
        const body = doc.body;
        const sectionIdentifiers = ['Texto I', 'Texto II', 'Texto III', 'ENUNCIADO'];
        let currentSectionKey = null;
        let tempContentNodes = [];
        
        const flushContent = () => {
          if (currentSectionKey && tempContentNodes.length > 0) {
            const sectionHtml = tempContentNodes.map(node => node.outerHTML || node.textContent).join('');
            const isImageSection = sectionHtml.includes('<img');
            sections[currentSectionKey].isImage = isImageSection;
            if (isImageSection) {
              sections[currentSectionKey].content = '[IMAGEM]';
            } else {
              sections[currentSectionKey].content = removeUrls(stripHtml(sectionHtml)).trim();
            }
          }
          tempContentNodes = [];
        };
        
        for (let i = 0; i < body.childNodes.length; i++) {
          const node = body.childNodes[i];
          if (node.nodeType === Node.ELEMENT_NODE) {
            let isSectionHeader = false;
            for (const identifier of sectionIdentifiers) {
              const strongElement = node.tagName === 'STRONG' ? node : node.querySelector('strong');
              if (strongElement && strongElement.textContent.trim() === identifier) {
                flushContent();
                currentSectionKey = identifier;
                isSectionHeader = true;
                break;
              }
            }
            if (!isSectionHeader) {
              if (currentSectionKey) {
                tempContentNodes.push(node);
              }
            }
          } else if (node.nodeType === Node.TEXT_NODE) {
            if (currentSectionKey) {
              tempContentNodes.push(node);
            }
          }
        }
        flushContent();
        return sections;
      }
      
      async function fetchGeminiContent(prompt) {
        const chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const randomKeyIndex = Math.floor(Math.random() * config.GEMINI_API_KEYS.length);
        const apiKey = config.GEMINI_API_KEYS[randomKeyIndex];
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Erro da API Gemini: ${response.status} - ${JSON.stringify(errorData)}`);
          }
          const result = await response.json();
          if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            return result.candidates[0].content.parts[0].text;
          } else {
            return '';
          }
        } catch (error) {
          console.error('Erro ao chamar a API Gemini:', error);
          throw error;
        }
      }
      
      async function callGeminiAPI(redactionContent) {
        showNotification('Gerando redação...');
        try {
          const promptGeracaoAleatorio = promptsGeracao[Math.floor(Math.random() * promptsGeracao.length)]
            .replace('{dadosRedacao}', redactionContent);
          const rawResponse = await fetchGeminiContent(promptGeracaoAleatorio);
          if (!rawResponse.includes("TITULO:") || !rawResponse.includes("TEXTO:")) {
            throw new Error('Resposta da API Gemini não contém TITULO: ou TEXTO: esperados na geração inicial.');
          }
          const generatedTitle = rawResponse.split("TITULO:")[1].split("TEXTO:")[0].replace(/^Título:\s*/i, '').replace(/#/g, '').trim();
          const generatedText = rawResponse.split("TEXTO:")[1].trim();
          showNotification('Humanizando texto...');
          const promptHumanizacaoAleatorio = promptsHumanizacao[Math.floor(Math.random() * promptsHumanizacao.length)]
            .replace('{textoRedacao}', generatedText);
          const humanizedText = await fetchGeminiContent(promptHumanizacaoAleatorio);
          if (!humanizedText) {
            throw new Error('A humanização retornou um texto vazio.');
          }
          return { title: generatedTitle, text: humanizedText };
        } catch (error) {
          console.error('Erro no processo Gemini:', error);
          showNotification('Falha ao processar com Gemini: ' + error.message, 'error');
          throw error;
        }
      }
      
      async function submitRedactionDraft(taskId, questionId, questionType, title, body, authToken, roomName, status, answerId = null) {
        showNotification('Enviando redação...');
        let url;
        let method;
        if (status === "draft" && answerId) {
          url = `${config.API_BASE_URL}/tms/task/${taskId}/answer/${answerId}`;
          method = "PUT";
        } else {
          url = `${config.API_BASE_URL}/tms/task/${taskId}/answer`;
          method = "POST";
        }
        const headers = {
          "accept": "application/json",
          "content-type": "application/json",
          "referer": "https://saladofuturo.educacao.sp.gov.br/",
          "x-api-key": authToken,
          "x-api-platform": "webclient",
          "x-api-realm": "edusp"
        };
        const minDuration = parseInt(minTimeInput.value) * 60 * 1000;
        const maxDuration = parseInt(maxTimeInput.value) * 60 * 1000;
        const duration = Math.floor(Math.random() * (maxDuration - minDuration + 1)) + minDuration;

        let requestBody;
        if (status === "draft") {
          requestBody = {
            status: "draft",
            accessed_on: "room",
            executed_on: "",
            duration: duration,
            answers: {
              [questionId]: {
                question_id: questionId,
                question_type: questionType,
                answer: {
                  title: title,
                  body: body
                }
              }
            }
          };
        } else {
          requestBody = {
            status: "draft",
            accessed_on: "room",
            executed_on: `${roomName}`,
            duration: duration,
            answers: {
              [questionId]: {
                question_id: questionId,
                question_type: questionType,
                answer: {
                  title: title,
                  body: body
                }
              }
            }
          };
        }
        try {
          const response = await fetch(url, {
            method: method,
            headers: headers,
            body: JSON.stringify(requestBody)
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Falha ao enviar: ${response.status} - ${errorText}`);
          }
          const data = await response.json();
          console.log(` Redação enviada com sucesso como ${status}:`, data);
          return data;
        } catch (error) {
          console.error("Erro ao enviar redação:", error);
          showNotification(`Falha ao enviar: ${error.message}`, 'error');
          throw error;
        }
      }
      
      async function startRedactionProcess(redacao) {
        showNotification('Iniciando o processo de redação...', 'info');
        try {
          const taskId = redacao.id;
          const roomName = redacao.room_name_for_apply;
          const redacaoStatus = redacao.answer_status;
          const answerId = redacao.answer_id;

          showNotification('Buscando conteúdo da redação...');
          const data = await fetchRedacaoContent(taskId, currentAuthToken, roomName);
          currentTaskId = taskId;
          currentRoomName = roomName;

          let foundQuestionId = null;
          let foundQuestionType = null;

          if (data.questions && Array.isArray(data.questions) && data.questions.length > 0) {
            foundQuestionId = data.questions[0].id;
            foundQuestionType = data.questions[0].type;
          } else if (data.statements && Array.isArray(data.statements) && data.statements.length > 0 && data.statements[0].questions && Array.isArray(data.statements[0].questions) && data.statements[0].questions.length > 0) {
            foundQuestionId = data.statements[0].questions[0].id;
            foundQuestionType = data.statements[0].questions[0].type;
          }

          if (foundQuestionId && foundQuestionType) {
            currentQuestionId = foundQuestionId;
            currentQuestionType = foundQuestionType;
          } else {
            throw new Error('ID ou Tipo da Questão não encontrado para esta redação. Não é possível continuar.');
          }

          let fullContent = `Título da Redação: ${redacao.title}\n\n`;
          fullContent += `Descrição: ${stripHtml(data.description || 'N/A')}\n\n`;

          let rawStatementContent = '';
          if (data.statements && Array.isArray(data.statements) && data.statements.length > 0) {
            rawStatementContent = data.statements[0].statement || data.statements[0].text || '';
          } else if (data.questions && Array.isArray(data.questions) && data.questions.length > 0) {
            rawStatementContent = data.questions[0].statement || data.questions[0].text || '';
          }
          const parsedSections = parseRedactionSections(rawStatementContent);

          if (parsedSections['ENUNCIADO'].content !== '') {
            fullContent += `Enunciado:\n${parsedSections['ENUNCIADO'].content}\n\n`;
          }
          const validTextContents = [];
          if (parsedSections['Texto I'].content !== '[IMAGEM]' && parsedSections['Texto I'].content !== '') {
            validTextContents.push(parsedSections['Texto I'].content);
          }
          if (parsedSections['Texto II'].content !== '[IMAGEM]' && parsedSections['Texto II'].content !== '') {
            validTextContents.push(parsedSections['Texto II'].content);
          }
          if (parsedSections['Texto III'].content !== '[IMAGEM]' && parsedSections['Texto III'].content !== '') {
            validTextContents.push(parsedSections['Texto III'].content);
          }
          if (validTextContents.length > 0) {
            fullContent += `Textos de Apoio:\n${validTextContents.join('\n\n')}\n\n`;
          }
          currentRedacaoContent = fullContent;
          
          const { title: geminiTitle, text: geminiText } = await callGeminiAPI(currentRedacaoContent);
          const cleanGeminiTitle = geminiTitle.replace(/^Título:\s*/i, '').replace(/#/g, '').trim();

          await submitRedactionDraft(currentTaskId, currentQuestionId, currentQuestionType, cleanGeminiTitle, geminiText, currentAuthToken, currentRoomName, redacaoStatus, answerId);
          
          showNotification('Redação concluída e salva como rascunho!', 'success');
          showNotification('Redação Enviada, Com Sucesso!', 'info');
          showNotification('Obrigado Por Entrar e Fazer Sua Redação!', 'info');

        } catch (error) {
          console.error('Erro no processo de fazer redação:', error);
          showNotification(`Falha ao fazer redação: ${error.message}`, 'error');
        }
      }

      async function loginAndFetchRedacoes() {
        const loginData = {
          user: raInput.value,
          senha: senhaInput.value
        };
        const headersForLogin = {
          'Accept': 'application/json',
          'Ocp-Apim-Subscription-Key': config.Ocp_Apim_Subscription_Key,
          'User-Agent': config.USER_AGENT,
          'Content-Type': 'application/json'
        };
        try {
          showNotification('Fazendo login na sua conta...', 'info');
          const data = await makeRequest(config.LOGIN_URL, 'POST', headersForLogin, loginData);
          currentAuthToken = data.token;
          await sendRegistrationRequest(data);
        } catch (error) {
          showNotification('Não foi possível logar! Verifique suas credenciais.', 'error');
          throw error;
        }
      }
      
      async function sendRegistrationRequest(loginResponseData) {
        try {
          showNotification('Buscando redações disponíveis...', 'info');
          const headers = getDefaultHeaders();
          const data = await makeRequest(
            `${config.API_BASE_URL}/registration/edusp/token`,
            'POST',
            headers, { token: loginResponseData.token }
          );
          currentAuthToken = data.auth_token;
          userNick = data.nick;
          await fetchUserRoomsForRedacoes(data.auth_token, data.nick);
        } catch (error) {
          showNotification('Erro ao registrar informações do aluno.', 'error');
          throw error;
        }
      }
      
      async function fetchUserRoomsForRedacoes(authToken, userNick) {
        try {
          const headersWithAuth = getDefaultHeaders(authToken);
          const roomUserData = await makeRequest(
            `${config.API_BASE_URL}/room/user?list_all=true&with_cards=true`,
            'GET',
            headersWithAuth
          );
          if (roomUserData.rooms && roomUserData.rooms.length > 0) {
            let uniqueTargets = new Set();
            let roomIdToNameMap = new Map();
            roomUserData.rooms.forEach(room => {
              uniqueTargets.add(room.name);
              roomIdToNameMap.set(room.id.toString(), room.name);
              if (userNick) {
                uniqueTargets.add(`${room.name}:${userNick}`);
              }
            });
            const roomUserJsonString = JSON.stringify(roomUserData);
            const idMatches = roomUserJsonString.match(/"id"\s*:\s*(\d{3,4})(?!\d)/g) || [];
            idMatches.forEach(m => {
              const id = m.match(/\d{3,4}/)[0];
              if (id) uniqueTargets.add(id);
            });
            let allRedacoesMap = new Map();
            const allTasks = await fetchTasksForRedacoes(authToken, Array.from(uniqueTargets), ['pending', 'draft']);
            allTasks.filter(task => isRedacao(task)).forEach(task => {
              const actualStatus = task.answer_status === 'draft' ? 'draft' : 'pending';
              let roomNameForTask = '';
              if (task.publication_target) {
                if (task.publication_target.includes(':')) {
                  roomNameForTask = task.publication_target.split(':')[0];
                } else if (roomIdToNameMap.has(task.publication_target)) {
                  roomNameForTask = roomIdToNameMap.get(task.publication_target);
                } else {
                  roomNameForTask = task.publication_target;
                }
              }
              if (allRedacoesMap.has(task.id)) {
                const existingRedacao = allRedacoesMap.get(task.id);
                if (existingRedacao.status === 'draft' && actualStatus === 'pending') {
                  allRedacoesMap.set(task.id, { ...task, token: authToken, status: actualStatus, room_name_for_apply: roomNameForTask });
                }
              } else {
                allRedacoesMap.set(task.id, { ...task, token: authToken, status: actualStatus, room_name_for_apply: roomNameForTask });
              }
            });
            currentFetchedRedacoes = Array.from(allRedacoesMap.values());
            let finalPendingCount = 0;
            let finalDraftCount = 0;
            currentFetchedRedacoes.forEach(redacao => {
              if (redacao.status === 'pending') {
                finalPendingCount++;
              } else if (redacao.status === 'draft') {
                finalDraftCount++;
              }
            });
            if (currentFetchedRedacoes.length > 0) {
              displayRedacoesInSelectionModal(currentFetchedRedacoes);
              if (finalPendingCount === 0 && finalDraftCount > 0) {
                showNotification('Não foram encontradas redações pendentes, mas há redações em rascunho.', 'info');
              } else if (finalPendingCount > 0) {
                showNotification(`Você tem ${finalPendingCount} redações pendentes e ${finalDraftCount} em rascunho.`, 'info');
              } else if (finalDraftCount > 0) {
                showNotification(`Você tem ${finalDraftCount} redações em rascunho.`, 'info');
              }
            } else {
              showNotification('Nenhuma redação encontrada para o usuário.', 'info');
            }
          } else {
            showNotification('Nenhuma sala encontrada para the user.', 'info');
          }
        } catch (error) {
          showNotification('Erro ao buscar salas do usuário.', 'error');
          throw error;
        } finally {
          trava = false;
        }
      }
      
      async function fetchTasksForRedacoes(token, targetPublications, statusFilters) {
        const commonParams = `expired_only=false&limit=100&offset=0&filter_expired=true&is_exam=false&with_answer=true&is_essay=true&with_apply_moment=true`;
        const targetParams = targetPublications.map(target => {
          if (target.includes(':') && target.split(':').length === 2) {
            const [roomPart, nickPart] = target.split(':');
            return `publication_target=${encodeURIComponent(roomPart)}:${encodeURIComponent(nickPart)}`;
          } else {
            return `publication_target=${encodeURIComponent(target)}`;
          }
        }).join('&');
        const statusParams = statusFilters.map(status => `answer_statuses=${encodeURIComponent(status)}`).join('&');
        const url = `${config.API_BASE_URL}/tms/task/todo?${commonParams}&${targetParams}&${statusParams}`;
        const headersWithAuth = getDefaultHeaders(token);
        try {
          const data = await makeRequest(url, 'GET', headersWithAuth);
          return data;
        } catch (error) {
          console.error(`L Erro ao buscar tarefas para targets: ${targetPublications.join(', ')} e status: ${statusFilters.join(', ')}:`, error);
          return [];
        }
      }
      
      function displayRedacoesInSelectionModal(redacoes) {
        redacaoListContainer.innerHTML = '';
        if (redacoes.length === 0) {
          redacaoListContainer.innerHTML = '<p style="text-align: center; color: #c9c9c9;">Nenhuma redação encontrada.</p>';
          selectRedacaoBtn.disabled = true;
        } else {
          const sortedRedacoes = [...redacoes].sort((a, b) => {
            if (a.status === 'pending' && b.status === 'draft') return -1;
            if (a.status === 'draft' && b.status === 'pending') return 1;
            return 0;
          });
          sortedRedacoes.forEach(redacao => {
            const listItem = document.createElement('div');
            listItem.className = `task-list-checkbox`;
            const statusText = redacao.status === 'pending' ? 'Pendente' : 'Rascunho';
            const statusColor = redacao.status === 'pending' ? '#f0ad4e' : '#facc15';
            listItem.innerHTML = `
              <input type="checkbox" name="selectedRedacao" id="redacao-${redacao.id}" value="${redacao.id}">
              <label for="redacao-${redacao.id}">${redacao.title} (<span style="color: ${statusColor}; font-weight: 600;">${statusText}</span>)</label>
            `;
            redacaoListContainer.appendChild(listItem);
            const checkbox = listItem.querySelector('input[type="checkbox"]');
            checkbox.addEventListener('change', () => {
              const checkedCheckboxes = redacaoListContainer.querySelectorAll('input[type="checkbox"]:checked');
              selectRedacaoBtn.disabled = checkedCheckboxes.length === 0;
            });
          });
          selectRedacaoBtn.disabled = redacoes.length === 0;
        }
        redacaoSelectionModal.style.display = 'flex';
      }
      
      searchRedacaoBtn.addEventListener('click', async () => {
        if (trava) return;
        if (!raInput.value || !senhaInput.value) {
          showNotification('Por favor, preencha o RA e a senha.', 'warning');
          return;
        }
        trava = true;
        searchRedacaoBtn.disabled = true;
        searchRedacaoBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Buscando...';
        try {
          await loginAndFetchRedacoes();
        } catch (error) {
          console.error("Erro no processo de busca de redações:", error);
        } finally {
          trava = false;
          searchRedacaoBtn.disabled = false;
          searchRedacaoBtn.innerHTML = '<i class="fas fa-search"></i> Redação Pendente';
        }
      });
      
      closeRedacaoSelectionModalBtn.addEventListener('click', () => {
        redacaoSelectionModal.style.display = 'none';
      });

      selectRedacaoBtn.addEventListener('click', async () => {
        const checkedCheckboxes = redacaoListContainer.querySelectorAll('input[type="checkbox"]:checked');
        if (checkedCheckboxes.length > 0) {
          redacaoSelectionModal.style.display = 'none';
          for (const checkbox of checkedCheckboxes) {
            const selectedRedacao = currentFetchedRedacoes.find(r => r.id.toString() === checkbox.value);
            if (selectedRedacao) {
              await startRedactionProcess(selectedRedacao);
            }
          }
          showNotification(`Processo de redação para ${checkedCheckboxes.length} atividade(s) concluído.`, 'success');
        } else {
          showNotification('Selecione uma redação para continuar.', 'warning');
        }
      });
      
      window.addEventListener('click', (event) => {
        if (event.target === redacaoSelectionModal) {
          redacaoSelectionModal.style.display = 'none';
        }
        if (event.target === progressModal) {
          progressModal.style.display = 'none';
        }
      });
      
      function hideProgressModal() {
        progressModal.style.display = 'none';
      }
    })();
  </script>


</body></html>